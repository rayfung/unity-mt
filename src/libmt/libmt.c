#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "libmt.h"

int find_touch_device(mt_context *ctx, int *id_return)
{
	// XIAllMasterDevices is used by Unity3D so we cannot use it

	// The first master pointer device (typically named "Virtual core pointer")
	// cannot receive events from the first touch in some cases so we don't use it

	// Solution:
	// Listen to all devices and filter out duplicate events generated by master devices

	*id_return = XIAllDevices;
	return 1;

	/*
	XIDeviceInfo *info;
	int ndevices;
	int found = 0;

	// Find master device only (because slave device can be added or removed at runtime)
	info = XIQueryDevice(ctx->display, XIAllMasterDevices, &ndevices);

	// Log all master pointer devices and select the first one
	for (int i = 0; i < ndevices; i++)
	{
		XIDeviceInfo *dev = &info[i];
		if (dev->use == XIMasterPointer)
		{
			int id = dev->deviceid;
			fprintf(stderr, "MT: Master pointer device: id=%d name=%s\n", id, dev->name);

			if (!found)
			{
				*id_return = id;
				found = 1;
			}
		}
	}

	XIFreeDeviceInfo(info);
	return found;
	*/
}

int find_my_window(mt_context *ctx, Window *my_window)
{
	// TODO: Find my window by current process id

	int found = 0;
	Window root = DefaultRootWindow(ctx->display);

	Window wr, wp;
	Window *children;
	unsigned int cnt;
	XQueryTree(ctx->display, root, &wr, &wp, &children, &cnt);
	for (unsigned int i = 0; i < cnt; ++i)
	{
		Window win = children[i];
		fprintf(stderr, "MT: Found window 0x%lx\n", (unsigned long)win);

		if (!found)
		{
			*my_window = win;
			found = 1;
		}
	}

	// 'children' is NULL when there are no children
	// and NULL cannot be passed to XFree
	if (children)
	{
		XFree(children);
	}
	return found;
}

void *mt_initialize()
{
	mt_context *ctx = malloc(sizeof(mt_context));
	if (!ctx)
	{
		fprintf(stderr, "MT: Failed to create touch context\n");
		return NULL;
	}

	ctx->display = XOpenDisplay(NULL);
	if (!ctx->display)
	{
		fprintf(stderr, "MT: Failed to open display\n");
		return NULL;
	}

	int event, error;
	if (!XQueryExtension(ctx->display, "XInputExtension", &ctx->xi_opcode, &event, &error))
	{
		fprintf(stderr, "MT: X Input extension not available.\n");
		return NULL;
	}

	int major = 2, minor = 2;
	if (XIQueryVersion(ctx->display, &major, &minor) != Success)
	{
		fprintf(stderr, "MT: XI 2.2 not available. Server supports %d.%d\n", major, minor);
		return NULL;
	}

	int use_device;
	if (!find_touch_device(ctx, &use_device))
	{
		fprintf(stderr, "MT: Couldn't find a touch device\n");
		return NULL;
	}

	Window my_window;
	if (!find_my_window(ctx, &my_window))
	{
		fprintf(stderr, "MT: Couldn't find my window\n");
		return NULL;
	}

	fprintf(stderr, "MT: Listening to events from device %d and window 0x%lx\n",
			use_device, (unsigned long)my_window);

	unsigned char mask[XIMaskLen(XI_LASTEVENT)] = { 0 };
	XIEventMask event_mask;
	event_mask.deviceid = use_device;
	event_mask.mask_len = sizeof(mask);
	event_mask.mask = mask;

	XISetMask(mask, XI_TouchBegin);
	XISetMask(mask, XI_TouchUpdate);
	XISetMask(mask, XI_TouchEnd);

	XISelectEvents(ctx->display, my_window, &event_mask, 1);
	XSync(ctx->display, False);
	return ctx;
}

mt_event mt_get_next(void *_ctx)
{
	mt_context *ctx = (mt_context *)_ctx;
	mt_event result;

	while (1)
	{
		if (!ctx || XPending(ctx->display) == 0)
		{
			result.type = MT_NONE;
			result.id = 0;
			result.x = 0;
			result.y = 0;
			return result;
		}

		int dev_id = -1, src_id = -1;
		XEvent event;
		XNextEvent(ctx->display, &event);

		if (XGetEventData(ctx->display, &event.xcookie) &&
				event.xcookie.type == GenericEvent &&
				event.xcookie.extension == ctx->xi_opcode)
		{
			XIDeviceEvent* de = event.xcookie.data;
			switch (de->evtype)
			{
				case XI_TouchBegin:
					result.type = MT_BEGIN;
					break;
				case XI_TouchUpdate:
					result.type = MT_UPDATE;
					break;
				case XI_TouchEnd:
					result.type = MT_END;
					break;
				default:
					result.type = MT_UNKNOWN;
					break;
			}

			result.id = de->detail;
			result.x = de->root_x;
			result.y = de->root_y;
			dev_id = de->deviceid;
			src_id = de->sourceid;
		}
		else
		{
			result.type = MT_UNKNOWN;
			result.id = 0;
			result.x = 0;
			result.y = 0;
		}

		XFreeEventData(ctx->display, &event.xcookie);

		// Only accept events from slave devices to avoid duplicate events
		if (result.type != MT_UNKNOWN && dev_id == src_id)
		{
			// fprintf(stderr, "MT: dev=%d src=%d type=%d id=%d x=%.1f y=%.1f\n",
			// 		dev_id, src_id, result.type, result.id, result.x, result.y);
			return result;
		}
	}
}

void mt_finalize(void *_ctx)
{
	mt_context *ctx = (mt_context *)_ctx;
	if (!ctx)
	{
		return;
	}

	XCloseDisplay(ctx->display);
	free(ctx);
	fprintf(stderr, "MT: Finalized\n");
}
